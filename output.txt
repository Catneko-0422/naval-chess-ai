#naval-chess-ai/frontend\src\app\page.tsx
"use client";

import Board from "../components/Board";
import Sidebar from "../components/Sidebar";
import StatusPanel from "../components/StatusPanel";
import useGameStore from "../store/gameStore";
import { motion } from "framer-motion";

export default function Home() {
  const { gameStatus } = useGameStore();

  const pageVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: { opacity: 1, y: 0, transition: { when: "beforeChildren", staggerChildren: 0.1 } }
  };

  return (
    <motion.main
      className="w-full max-w-screen-xl mx-auto px-6 py-8 flex flex-col"
      initial="hidden"
      animate="visible"
      variants={pageVariants}
    >
      <motion.h1
        className="text-4xl font-extrabold text-center text-white mb-8"
        variants={{ hidden: { opacity: 0 }, visible: { opacity: 1, transition: { duration: 0.5 } } }}
      >
        æµ·æˆ°æ£‹å¤§ä½œæˆ°
      </motion.h1>

      <div className="flex flex-col md:flex-row gap-8">
        <Board who={gameStatus === "waiting" ? "player" : "opponent"} />
        <Sidebar />
      </div>

      <StatusPanel />
    </motion.main>
  );
}


#naval-chess-ai/frontend\src\components\Board.tsx
// src/components/Board.tsx
"use client";

import React, { useEffect, useRef, useState } from "react";
import useGameStore, { Ship } from "../store/gameStore";

interface BoardProps {
  who: "player" | "opponent";
}

export default function Board({ who }: BoardProps) {
  const {
    playerId,          // â†—ï¸ æ‹¿åˆ°æˆ‘å€‘çš„ playerId
    ships,
    sunkenShips,
    showShips,
    initializeShips,
    connectToServer,
    gameStatus,
    currentTurn,
    socket,            // å…¶å¯¦ä¸å†å¯¹æ¯” socket.id
    moveShip,
    rotateShip,
    makeMove,
    opMatrix,
    myMatrix,
  } = useGameStore();

  const inited = useRef(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const [gridSize, setGridSize] = useState(0);

  useEffect(() => {
    if (!inited.current) {
      initializeShips();
      connectToServer();
      inited.current = true;
    }
    const updateSize = () => {
      if (containerRef.current) {
        const usable = containerRef.current.clientWidth - 9;
        setGridSize(Math.floor(usable / 10));
      }
    };
    updateSize();
    window.addEventListener("resize", updateSize);
    return () => window.removeEventListener("resize", updateSize);
  }, [initializeShips, connectToServer]);

  const isPlayer = who === "player";
  const matrix = showShips(ships);
  const hits = isPlayer ? myMatrix : opMatrix;

  return (
    <div
      ref={containerRef}
      className="w-full max-w-screen-lg overflow-x-auto bg-gray-800 p-[1px] rounded-lg"
    >
      <div
        className="relative"
        style={{ width: gridSize * 10, height: gridSize * 10 }}
      >
        <div className="grid grid-cols-10 grid-rows-10 absolute top-0 left-0">
          {matrix.map((row, r) =>
            row.map((cell, c) => {
              const showShip = isPlayer && cell === 1 && !sunkenShips.includes(cell);
              const hitState = hits[r][c]; // 0=æœªæ‰“, 2=å‘½ä¸­,3=æœªå‘½ä¸­
              const canClick =
                who === "opponent" &&
                gameStatus === "playing" &&
                currentTurn === playerId &&    // âœ… æ”¹ç”¨ playerId åˆ¤æ–­
                hitState === 0;
              return (
                <div
                  key={`${r}-${c}`}
                  className={[
                    "aspect-square border border-gray-600",
                    showShip ? "bg-gray-400" : "bg-gray-700",
                    canClick ? "cursor-pointer" : "",
                  ]
                    .filter(Boolean)
                    .join(" ")}
                  style={{ width: gridSize, height: gridSize }}
                  onClick={() => canClick && makeMove(r, c)}
                  onDragOver={(e) => e.preventDefault()}
                  onDrop={(e) => {
                    if (isPlayer && gameStatus === "waiting") {
                      const id = e.dataTransfer.getData("shipId");
                      id && moveShip(Number(id), r, c);
                    }
                  }}
                >
                  {hitState === 2 && (
                    <img
                      src="/hit.png"
                      alt="hit"
                      className="w-full h-full pointer-events-none"
                    />
                  )}
                  {hitState === 3 && (
                    <img
                      src="/no_hit.png"
                      alt="miss"
                      className="w-full h-full pointer-events-none"
                    />
                  )}
                </div>
              );
            })
          )}
        </div>

        {/* ç­‰å¾…é˜¶æ®µï¼šç©å®¶å¸ƒèˆ° */}
        {isPlayer &&
          gameStatus === "waiting" &&
          ships.map((ship: Ship) => {
            const { id, size, row, col, orientation, imageId } = ship;
            const isSpecial = imageId !== size;
            const imageUrl = isSpecial
              ? `/ships/ship-${size}-${orientation === "horizontal" ? "h" : "v"}-${imageId}.png`
              : `/ships/ship-${size}-${orientation === "horizontal" ? "h" : "v"}.png`;
            const w = orientation === "horizontal" ? size * gridSize : gridSize;
            const h = orientation === "horizontal" ? gridSize : size * gridSize;
            return (
              <img
                key={id}
                src={imageUrl}
                alt={`ship-${id}`}
                draggable
                onDragStart={(e) => e.dataTransfer.setData("shipId", id.toString())}
                onClick={() => rotateShip(id)}
                className="absolute z-10"
                style={{
                  top: row * gridSize,
                  left: col * gridSize,
                  width: w,
                  height: h,
                  cursor: "pointer",
                }}
              />
            );
          })}

        {/* å·²å‡»æ²‰æ•´è‰˜èˆ¹ */}
        {sunkenShips.map((sid) => {
          const ship = ships.find((s) => s.id === sid);
          if (!ship) return null;
          const { size, row, col, orientation, imageId } = ship;
          const isSpecial = imageId !== size;
          const imageUrl = isSpecial
            ? `/ships/ship-${size}-${
                orientation === "horizontal" ? "h" : "v"
              }-${imageId}.png`
            : `/ships/ship-${size}-${
                orientation === "horizontal" ? "h" : "v"
              }.png`;
          const w = orientation === "horizontal" ? size * gridSize : gridSize;
          const h = orientation === "horizontal" ? gridSize : size * gridSize;
          return (
            <img
              key={`sunken-${sid}`}
              src={imageUrl}
              alt={`sunken-${sid}`}
              className="absolute opacity-80 z-20"
              style={{
                top: row * gridSize,
                left: col * gridSize,
                width: w,
                height: h,
              }}
            />
          );
        })}
      </div>
    </div>
  );
}


#naval-chess-ai/frontend\src\components\GameBoard.tsx
// src/store/gameStore.ts

import { create } from "zustand";
import { io, Socket } from "socket.io-client";

export interface Ship {
  id: number;
  size: number;
  row: number;
  col: number;
  orientation: "horizontal" | "vertical";
  imageId?: number;
}

interface LastMove {
  attacker: string;
  x: number;
  y: number;
  hit: boolean;
}

interface GameState {
  ships: Ship[];
  socket: Socket | null;
  gameStatus: "waiting" | "playing" | "finished";
  currentTurn: string | null;
  opponentId: string | null;
  roomId: string | null;
  playerId: string | null;
  isAiGame: boolean;
  sunkenShips: number[];
  lastMove: LastMove | null;
  lastSunken: number[];
  opMatrix: number[][];
  myMatrix: number[][];

  // setters
  setOpMatrixCell: (x: number, y: number, v: number) => void;
  setMyMatrixCell: (x: number, y: number, v: number) => void;
  setPlayerId: (id: string) => void;
  setSunkenShips: (ids: number[]) => void;
  setLastMove: (lm: LastMove) => void;
  setLastSunken: (ids: number[]) => void;

  // actions
  initializeShips: () => void;
  moveShip: (id: number, row: number, col: number) => void;
  rotateShip: (id: number) => void;
  showShips: (ships: Ship[]) => number[][];
  connectToServer: () => void;
  joinGame: (isAi: boolean) => void;
  makeMove: (x: number, y: number) => void;
}

const GRID_SIZE = 10;
const emptyMatrix = () =>
  Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));

export default create<GameState>((set, get) => ({
  ships: [],
  socket: null,
  gameStatus: "waiting",
  currentTurn: null,
  opponentId: null,
  roomId: null,
  playerId: null,
  isAiGame: false,
  sunkenShips: [],
  lastMove: null,
  lastSunken: [],
  opMatrix: emptyMatrix(),
  myMatrix: emptyMatrix(),

  // ---- setters ----
  setOpMatrixCell: (x, y, v) =>
    set((state) => {
      const m = state.opMatrix.map((r) => r.slice());
      m[x][y] = v;
      return { opMatrix: m };
    }),
  setMyMatrixCell: (x, y, v) =>
    set((state) => {
      const m = state.myMatrix.map((r) => r.slice());
      m[x][y] = v;
      return { myMatrix: m };
    }),
  setPlayerId: (id) => set({ playerId: id }),
  setSunkenShips: (ids) => set({ sunkenShips: ids }),
  setLastMove: (lm) => set({ lastMove: lm }),
  setLastSunken: (ids) => set({ lastSunken: ids }),

  // ---- initialization ----
  initializeShips: async () => {
    const res = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/api/generate_board`
    );
    const data = await res.json();
    const shipsWithImage = data.ships.map((s: Ship) => ({
      ...s,
      imageId: s.size === 3 && s.id === 2 ? 2 : s.size,
    }));
    set({ ships: shipsWithImage });
  },

  // ---- ship placement ----
  moveShip: (id, targetRow, targetCol) => {
    const ships = get().ships;
    const ship = ships.find((s) => s.id === id);
    if (!ship) return;
    const others = ships.filter((s) => s.id !== id);
    const { row, col } = findNearestValidPosition(
      targetRow,
      targetCol,
      ship.orientation,
      ship.size,
      others
    );
    set((state) => ({
      ships: state.ships.map((s) =>
        s.id === id ? { ...s, row, col } : s
      ),
    }));
  },

  rotateShip: (id) => {
    const ships = get().ships;
    const ship = ships.find((s) => s.id === id);
    if (!ship) return;
    const newOri = ship.orientation === "horizontal" ? "vertical" : "horizontal";
    const others = ships.filter((s) => s.id !== id);
    const { row, col } = findNearestValidPosition(
      ship.row,
      ship.col,
      newOri,
      ship.size,
      others
    );
    set((state) => ({
      ships: state.ships.map((s) =>
        s.id === id ? { ...s, orientation: newOri, row, col } : s
      ),
    }));
  },

  showShips: (ships) => {
    const m = emptyMatrix();
    ships.forEach((sh) =>
      Array(sh.size)
        .fill(0)
        .forEach((_, i) => {
          const r = sh.orientation === "vertical" ? sh.row + i : sh.row;
          const c = sh.orientation === "horizontal" ? sh.col + i : sh.col;
          m[r][c] = 1;
        })
    );
    return m;
  },

  // ---- networking ----
  connectToServer: () => {
    const socket = io(
      process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000",
      { transports: ["websocket"] }
    );

    socket.on("connect", () => set({ socket }));

    // 1) æ”¶åˆ° joined_gameï¼šå…ˆæ‹¿åˆ° roomIdï¼Œå†å»å• /api/opponent
    socket.on("joined_game", async ({ room_id }) => {
      set({ roomId: room_id });

      // å¦‚æœæ˜¯ PVPï¼ˆé AIï¼‰ï¼Œå‘¼å« /api/opponent
      if (!get().isAiGame) {
        try {
          const res = await fetch(
            `${process.env.NEXT_PUBLIC_API_URL}/api/opponent`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                room_id,
                player: get().playerId!,
              }),
            }
          );
          if (!res.ok) {
            console.error("æŸ¥è©¢å°æ‰‹ ID å¤±æ•—ï¼š", await res.text());
            return;
          }
          const { opponent_id } = await res.json();
          set({ opponentId: opponent_id });
        } catch (e) {
          console.error("å‘¼å« /api/opponent ç™¼ç”ŸéŒ¯èª¤", e);
        }
      }
    });

    // 2) match_successï¼šå¾Œç«¯ä¹Ÿæœƒç™¼ï¼Œç•¶ä½œå‚™æ´
    socket.on("match_success", ({ room_id }) => {
      const myId = get().playerId!;
      set({
        roomId: room_id,
        opponentId: myId === "player1" ? "player2" : "player1",
      });
    });

    socket.on("game_started", ({ first_turn }) =>
      set({ gameStatus: "playing", currentTurn: first_turn })
    );

    socket.on("move_made", async ({ attacker, x, y, hit }) => {
      const prev = get().sunkenShips;
      set({ lastSunken: [] });
      set({ lastMove: { attacker, x, y, hit } });

      // æ›´æ–°æ ¼å­
      if (attacker === get().playerId) {
        get().setOpMatrixCell(x, y, hit ? 2 : 3);
      } else {
        get().setMyMatrixCell(x, y, hit ? 2 : 3);
      }

      // å›åˆé‚è¼¯
      const nextTurn = hit
        ? attacker
        : attacker === get().playerId
        ? get().opponentId!
        : get().playerId!;
      set({ currentTurn: nextTurn });

      // å¦‚æœå‘½ä¸­ï¼ŒæŸ¥è©¢æ²‰è‰¦
      const { roomId, opponentId } = get();
      if (hit && roomId && opponentId) {
        try {
          const res = await fetch(
            `${process.env.NEXT_PUBLIC_API_URL}/api/sunken_ships`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                room_id: roomId,
                player:
                  attacker === get().playerId
                    ? opponentId
                    : get().playerId,
              }),
            }
          );
          if (res.ok) {
            const { sunken_ship_ids } = await res.json();
            const newIds = sunken_ship_ids.filter((id) => !prev.includes(id));
            set({
              sunkenShips: sunken_ship_ids,
              lastSunken: newIds,
            });
          } else {
            console.error("Bad /api/sunken_ships:", await res.text());
          }
        } catch (e) {
          console.error("æ²‰è‰¦æŸ¥è©¢å¤±æ•—", e);
        }
      }
    });

    socket.on("game_over", () => set({ gameStatus: "finished" }));
  },

  // åŠ å…¥éŠæˆ²ï¼ˆPVP / PVEï¼‰
  joinGame: (isAi = false) => {
    const { socket, ships, playerId } = get();
    if (!socket || !playerId) return;

    set({ isAiGame: isAi });
    if (isAi) {
      set({ opponentId: "AI" });
    } else {
      set({ opponentId: null });
    }

    const board = emptyMatrix();
    ships.forEach((ship) =>
      Array(ship.size)
        .fill(0)
        .forEach((_, i) => {
          const r = ship.orientation === "vertical" ? ship.row + i : ship.row;
          const c =
            ship.orientation === "horizontal" ? ship.col + i : ship.col;
          board[r][c] = 1;
        })
    );
    socket.emit("join_game", {
      player_id: playerId,
      board,
      ships,
      is_ai_game: isAi,
    });
  },

  makeMove: (x, y) => {
    const { socket, roomId, playerId, currentTurn } = get();
    if (!socket || !roomId || currentTurn !== playerId) return;
    socket.emit("make_move", { room_id: roomId, player: playerId, x, y });
  },
}));

// å¹«åŠ©å‡½å¼ï¼šæ‰¾æœ€è¿‘åˆæ³•ä½ç½®
function findNearestValidPosition(
  targetRow: number,
  targetCol: number,
  orientation: "horizontal" | "vertical",
  size: number,
  otherShips: Ship[]
): { row: number; col: number } {
  const max = GRID_SIZE;
  const clampRow = Math.min(
    Math.max(0, targetRow),
    orientation === "vertical" ? max - size : max - 1
  );
  const clampCol = Math.min(
    Math.max(0, targetCol),
    orientation === "horizontal" ? max - size : max - 1
  );

  for (let radius = 0; radius <= 3; radius++) {
    for (let dr = -radius; dr <= radius; dr++) {
      for (let dc = -radius; dc <= radius; dc++) {
        const r = clampRow + dr;
        const c = clampCol + dc;
        if (r < 0 || c < 0) continue;
        if (orientation === "vertical" && r + size > max) continue;
        if (orientation === "horizontal" && c + size > max) continue;
        const coords = Array.from({ length: size }, (_, i) => ({
          r: orientation === "vertical" ? r + i : r,
          c: orientation === "horizontal" ? c + i : c,
        }));
        const overlap = otherShips.some((os) =>
          coords.some((pt) =>
            os.orientation === "vertical"
              ? pt.c === os.col && pt.r >= os.row && pt.r < os.row + os.size
              : pt.r === os.row && pt.c >= os.col && pt.c < os.col + os.size
          )
        );
        if (!overlap) return { row: r, col: c };
      }
    }
  }
  return { row: clampRow, col: clampCol };
}


#naval-chess-ai/frontend\src\components\Piece.tsx
"use client";

import React from "react";
import { Ship } from "../store/gameStore";

interface PieceProps {
  ship: Ship;
  gridSize: number;
  draggable: boolean;
  onRotate: () => void;
}

const Piece: React.FC<PieceProps> = ({ ship, gridSize, draggable, onRotate }) => {
  // åˆ¤æ–­ç‰¹æ®Š size=3 ç¬¬äºŒè‰˜ç”¨ä¸åŒ imageId
  const isSpecial = ship.imageId !== undefined && ship.imageId !== ship.size;
  const imageUrl = isSpecial
    ? `/ships/ship-${ship.size}-${ship.orientation === "horizontal" ? "h" : "v"}-${ship.imageId}.png`
    : `/ships/ship-${ship.size}-${ship.orientation === "horizontal" ? "h" : "v"}.png`;

  const w = ship.orientation === "horizontal" ? ship.size * gridSize : gridSize;
  const h = ship.orientation === "horizontal" ? gridSize : ship.size * gridSize;

  return (
    <div
      className="absolute"
      style={{
        top: ship.row * gridSize,
        left: ship.col * gridSize,
        width: w,
        height: h,
        backgroundImage: `url(${imageUrl})`,
        backgroundSize: "contain",
        backgroundRepeat: "no-repeat",
        cursor: draggable ? "pointer" : "default",
        zIndex: 10,
      }}
      draggable={draggable}
      onDragStart={(e) => {
        if (draggable) e.dataTransfer.setData("shipId", ship.id.toString());
        else e.preventDefault();
      }}
      onClick={() => {
        if (draggable) onRotate();
      }}
    />
  );
};

export default Piece;


#naval-chess-ai/frontend\src\components\Sidebar.tsx
"use client";

import React, { useState } from "react";
import useGameStore from "../store/gameStore";
import { motion } from "framer-motion";

export default function Sidebar() {
  const {
    gameStatus,
    ships,
    showShips,
    playerId,
    myMatrix,       // è‡ªå·±çš„å‘½ä¸­/æœªå‘½ä¸­çŸ©é™£
    setPlayerId,
    joinGame,
  } = useGameStore();
  const [input, setInput] = useState("");

  const handlePvP = () => {
    const id = input.trim() || crypto.randomUUID();
    setPlayerId(id);
    joinGame(false);
  };
  const handlePvE = () => {
    const id = input.trim() || crypto.randomUUID();
    setPlayerId(id);
    joinGame(true);
  };

  return (
    <motion.div
      className="w-full md:w-1/3 flex flex-col gap-6"
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
    >
      <motion.div
        className="space-y-4"
        initial="hidden"
        animate="visible"
        variants={{ visible: { transition: { staggerChildren: 0.1 } } }}
      >
        <motion.input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="è¼¸å…¥ Player IDï¼ˆå¯ç•™ç©ºï¼‰"
          className="w-full p-3 rounded bg-gray-700 text-white placeholder-gray-400"
          variants={{ hidden: { opacity: 0 }, visible: { opacity: 1 } }}
        />
        <motion.button onClick={handlePvP}
          disabled={gameStatus !== "waiting"}
          className="w-full py-3 rounded bg-green-600 hover:bg-green-700 text-white"
          whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}
        >
          èˆ‡ç©å®¶å°æˆ°
        </motion.button>
        <motion.button onClick={handlePvE}
          disabled={gameStatus !== "waiting"}
          className="w-full py-3 rounded bg-blue-600 hover:bg-blue-700 text-white"
          whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}
        >
          èˆ‡ AI å°æˆ°
        </motion.button>
        <motion.button onClick={() => window.location.reload()}
          className="w-full py-3 rounded bg-gray-600 hover:bg-gray-700 text-white"
          whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}
        >
          ğŸ”„ é‡æ–°æ•´ç†
        </motion.button>
      </motion.div>

      {gameStatus === "playing" && (
        <div className="w-full grid grid-cols-10 gap-[1px] bg-gray-800">
          {showShips(ships).map((row, r) =>
            row.map((cell, c) => {
              const hasShip = cell === 1;
              const hitState = myMatrix[r][c]; // 0/2/3
              return (
                <div key={`${r}-${c}`}
                  className="relative aspect-square"
                >
                  <div className={`absolute inset-0 ${
                    hasShip ? "bg-gray-400" : "bg-transparent"
                  }`} />
                  {hitState === 2 && (
                    <img src="/hit.png" alt="hit"
                      className="absolute inset-0 w-full h-full pointer-events-none" />
                  )}
                  {hitState === 3 && (
                    <img src="/no_hit.png" alt="miss"
                      className="absolute inset-0 w-full h-full pointer-events-none" />
                  )}
                </div>
              );
            })
          )}
        </div>
      )}

      <motion.p className="text-sm text-gray-400 mt-auto text-center"
        initial={{ opacity: 0 }} animate={{ opacity: 1 }}
      >
        ç‰ˆæœ¬ï¼šv1.0
      </motion.p>
    </motion.div>
  );
}


#naval-chess-ai/frontend\src\components\StatusPanel.tsx
// src/components/StatusPanel.tsx
"use client";

import React from "react";
import useGameStore from "../store/gameStore";

export default function StatusPanel() {
  const {
    gameStatus,
    playerId,
    currentTurn,
    lastMove,
    lastSunken,
    sunkenShips,
  } = useGameStore();

  // éŠæˆ²å°šæœªé–‹å§‹å°±ä¸é¡¯ç¤º
  if (gameStatus === "waiting") return null;

  const isMyTurn = currentTurn === playerId;
  const turnText = isMyTurn ? "è¼ªåˆ°ä½ å‡ºæ‹›ï¼" : "å°æ‰‹çš„å›åˆ";

  return (
    <div className="w-full bg-gray-900 text-white p-4 rounded-lg mt-6">
        {/* å›åˆç‹€æ…‹ */}
        <p className="mb-2 font-semibold text-lg">{turnText}</p>

        {/* æœ€å¾Œä¸€æ¬¡æ”»æ“Šçµæœ */}
        {lastMove && (
            <p className="mb-2">
            æœ€å¾Œä¸€æ“Šï¼š{lastMove.attacker === playerId ? "ä½ " : "å°æ‰‹"} åœ¨
            ({lastMove.x},{lastMove.y})ï¼Œ
            {lastMove.hit ? "å‘½ä¸­ âœ”ï¸" : "æœªå‘½ä¸­ âŒ"}
            </p>
        )}

        { lastMove && lastSunken.length > 0 && (
        <p className="mb-2">
            ğŸ’¥ {lastMove.attacker === playerId ? "ä½ æ“Šæ²‰äº†" : "å°æ‰‹æ“Šæ²‰äº†"}{" "}
            {lastSunken.map(id =>
            ["æµ·é˜²è‰¦","é©…é€è‰¦","å·¡æ´‹è‰¦","æˆ°è‰¦","èˆªç©ºæ¯è‰¦"][id]
            ).join("ã€")}
        </p>
        )}

        {/* ç´¯è¨ˆå·²æ²‰è‰¦è‰‡ */}
        <p>å·²æ²‰è‰¦è‰‡ï¼š{sunkenShips.length} / 5</p>
    </div>
  );
}


#naval-chess-ai/frontend\src\store\gameStore.ts
// src/store/gameStore.ts
import { create } from "zustand";
import { io, Socket } from "socket.io-client";

export interface Ship {
  id: number;
  size: number;
  row: number;
  col: number;
  orientation: "horizontal" | "vertical";
  imageId?: number;
}
interface LastMove {
  attacker: string;
  x: number;
  y: number;
  hit: boolean;
}
interface GameState {
  ships: Ship[];
  socket: Socket | null;
  gameStatus: "waiting" | "playing" | "finished";
  currentTurn: string | null;
  opponentId: string | null;
  roomId: string | null;
  playerId: string | null;
  isAiGame: boolean;
  sunkenShips: number[];
  lastMove: LastMove | null;
  lastSunken: number[];
  opMatrix: number[][];
  myMatrix: number[][];
  // setters
  setOpMatrixCell: (x: number, y: number, v: number) => void;
  setMyMatrixCell: (x: number, y: number, v: number) => void;
  setPlayerId: (id: string) => void;
  setSunkenShips: (ids: number[]) => void;
  setLastMove: (lm: LastMove) => void;
  setLastSunken: (ids: number[]) => void;
  // actions
  initializeShips: () => void;
  moveShip: (id: number, row: number, col: number) => void;
  rotateShip: (id: number) => void;
  showShips: (ships: Ship[]) => number[][];
  connectToServer: () => void;
  joinGame: (isAi: boolean) => void;
  makeMove: (x: number, y: number) => void;
}

const GRID_SIZE = 10;
const emptyMatrix = () =>
  Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));

export default create<GameState>((set, get) => ({
  ships: [],
  socket: null,
  gameStatus: "waiting",
  currentTurn: null,
  opponentId: null,
  roomId: null,
  playerId: null,
  isAiGame: false,
  sunkenShips: [],
  lastMove: null,
  lastSunken: [],
  opMatrix: emptyMatrix(),
  myMatrix: emptyMatrix(),

  // ---- setters ----
  setOpMatrixCell: (x, y, v) =>
    set((state) => {
      const m = state.opMatrix.map((r) => r.slice());
      m[x][y] = v;
      return { opMatrix: m };
    }),
  setMyMatrixCell: (x, y, v) =>
    set((state) => {
      const m = state.myMatrix.map((r) => r.slice());
      m[x][y] = v;
      return { myMatrix: m };
    }),
  setPlayerId: (id) => set({ playerId: id }),
  setSunkenShips: (ids) => set({ sunkenShips: ids }),
  setLastMove: (lm) => set({ lastMove: lm }),
  setLastSunken: (ids) => set({ lastSunken: ids }),

  // ---- initialization ----
  initializeShips: async () => {
    const res = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/api/generate_board`
    );
    const data = await res.json();
    const shipsWithImage = data.ships.map((s: Ship) => ({
      ...s,
      imageId: s.size === 3 && s.id === 2 ? 2 : s.size,
    }));
    set({ ships: shipsWithImage });
  },

  // ---- ship placement ----
  moveShip: (id, targetRow, targetCol) => {
    const ships = get().ships;
    const ship = ships.find((s) => s.id === id);
    if (!ship) return;
    const others = ships.filter((s) => s.id !== id);
    const { row, col } = findNearestValidPosition(
      targetRow,
      targetCol,
      ship.orientation,
      ship.size,
      others
    );
    set((state) => ({
      ships: state.ships.map((s) =>
        s.id === id ? { ...s, row, col } : s
      ),
    }));
  },

  rotateShip: (id) => {
    const ships = get().ships;
    const ship = ships.find((s) => s.id === id);
    if (!ship) return;
    const newOri = ship.orientation === "horizontal" ? "vertical" : "horizontal";
    const others = ships.filter((s) => s.id !== id);
    const { row, col } = findNearestValidPosition(
      ship.row,
      ship.col,
      newOri,
      ship.size,
      others
    );
    set((state) => ({
      ships: state.ships.map((s) =>
        s.id === id ? { ...s, orientation: newOri, row, col } : s
      ),
    }));
  },

  showShips: (ships) => {
    const m = emptyMatrix();
    ships.forEach((sh) =>
      Array(sh.size)
        .fill(0)
        .forEach((_, i) => {
          const r = sh.orientation === "vertical" ? sh.row + i : sh.row;
          const c = sh.orientation === "horizontal" ? sh.col + i : sh.col;
          m[r][c] = 1;
        })
    );
    return m;
  },

  // ---- networking ----
  connectToServer: () => {
    const socket = io(
      process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000",
      { transports: ["websocket"] }
    );

    socket.on("connect", () => set({ socket }));

    // è¨˜éŒ„æˆ¿é–“
    socket.on("joined_game", ({ room_id }) => {
      set({ roomId: room_id });
    });

    // PVP é…å°æˆåŠŸ
    socket.on("match_success", ({ room_id }) => {
      const myId = get().playerId!;
      set({
        roomId: room_id,
        opponentId: myId === "player1" ? "player2" : "player1",
      });
    });

    socket.on("game_started", ({ first_turn }) =>
      set({ gameStatus: "playing", currentTurn: first_turn })
    );

    socket.on("move_made", async ({ attacker, x, y, hit }) => {
      // æ¸…æ‰ä¸Šä¸€å›åˆçš„æ²‰è‰¦è¨Šæ¯
      const prev = get().sunkenShips;
      set({ lastSunken: [] });

      // ç´€éŒ„é€™å›åˆå‡ºæ‹›
      set({ lastMove: { attacker, x, y, hit } });

      // æ›´æ–°å‘½ä¸­ï¼æœªå‘½ä¸­æ ¼å­
      if (attacker === get().playerId) {
        get().setOpMatrixCell(x, y, hit ? 2 : 3);
      } else {
        get().setMyMatrixCell(x, y, hit ? 2 : 3);
      }

      // å›åˆé‚è¼¯ï¼šå‘½ä¸­å‰‡åŒä¸€äººå†æ‰“ï¼Œå¦å‰‡æ›
      const nextTurn = hit
        ? attacker
        : attacker === get().playerId
        ? get().opponentId!
        : get().playerId!;
      set({ currentTurn: nextTurn });

      // å¦‚æœå‘½ä¸­ï¼Œå‘å¾Œç«¯æŸ¥è©¢æ²‰è‰¦
      const { roomId, opponentId } = get();

      
      if (hit && roomId && opponentId) {
        try {
          const res = await fetch(
            `${process.env.NEXT_PUBLIC_API_URL}/api/sunken_ships`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                room_id: roomId,
                player:
                  attacker === get().playerId
                    ? opponentId
                    : get().playerId,
              }),
            }
          );
          if (res.ok) {
            const { sunken_ship_ids } = await res.json();
            const newIds = sunken_ship_ids.filter((id) => !prev.includes(id));
            set({
              sunkenShips: sunken_ship_ids,
              lastSunken: newIds,
            });
          } else {
            console.error("Bad /api/sunken_ships:", await res.text());
            console.log("sunken_ships payload:", JSON.stringify({
              room_id: roomId,
              player: attacker === get().playerId ? opponentId : get().playerId
            }));
          }
        } catch (e) {
          console.error("æ²‰è‰¦æŸ¥è©¢å¤±æ•—", e);
        }
      }
    });

    socket.on("game_over", () => set({ gameStatus: "finished" }));
  },

  // åŠ å…¥éŠæˆ²ï¼ˆPVP / PVEï¼‰
  joinGame: (isAi = false) => {
    const { socket, ships, playerId } = get();
    if (!socket || !playerId) return;

    // 1) è¨˜éŒ„æ˜¯å¦ç‚º AI æ¨¡å¼
    set({ isAiGame: isAi });

    // 2) è‹¥ç‚º AIï¼Œç›´æ¥æŠŠ opponentId è¨­æˆ "AI"
    if (isAi) {
      set({ opponentId: "AI" });
    } else {
      // PVP å…ˆæ¸…ç©ºï¼Œç­‰å¾… match_success äº‹ä»¶å›ä¾†
      set({ opponentId: null });
    }

    // 3) å‚³é€å¸ƒé™£
    const board = emptyMatrix();
    ships.forEach((ship) =>
      Array(ship.size)
        .fill(0)
        .forEach((_, i) => {
          const r = ship.orientation === "vertical" ? ship.row + i : ship.row;
          const c =
            ship.orientation === "horizontal" ? ship.col + i : ship.col;
          board[r][c] = 1;
        })
    );
    socket.emit("join_game", {
      player_id: playerId,
      board,
      ships,
      is_ai_game: isAi,
    });
  },

  makeMove: (x, y) => {
    const { socket, roomId, playerId, currentTurn } = get();
    if (!socket || !roomId || currentTurn !== playerId) return;
    socket.emit("make_move", { room_id: roomId, player: playerId, x, y });
  },
}));

// è¼”åŠ©ï¼šæ‰¾æœ€è¿‘åˆæ³•ä½ç½®
function findNearestValidPosition(
  targetRow: number,
  targetCol: number,
  orientation: "horizontal" | "vertical",
  size: number,
  otherShips: Ship[]
): { row: number; col: number } {
  const max = GRID_SIZE;
  const clampRow = Math.min(
    Math.max(0, targetRow),
    orientation === "vertical" ? max - size : max - 1
  );
  const clampCol = Math.min(
    Math.max(0, targetCol),
    orientation === "horizontal" ? max - size : max - 1
  );
  for (let radius = 0; radius <= 3; radius++) {
    for (let dr = -radius; dr <= radius; dr++) {
      for (let dc = -radius; dc <= radius; dc++) {
        const r = clampRow + dr;
        const c = clampCol + dc;
        if (r < 0 || c < 0) continue;
        if (orientation === "vertical" && r + size > max) continue;
        if (orientation === "horizontal" && c + size > max) continue;
        const coords = Array.from({ length: size }, (_, i) => ({
          r: orientation === "vertical" ? r + i : r,
          c: orientation === "horizontal" ? c + i : c,
        }));
        const overlap = otherShips.some((os) =>
          coords.some((pt) =>
            os.orientation === "vertical"
              ? pt.c === os.col && pt.r >= os.row && pt.r < os.row + os.size
              : pt.r === os.row && pt.c >= os.col && pt.c < os.col + os.size
          )
        );
        if (!overlap) return { row: r, col: c };
      }
    }
  }
  return { row: clampRow, col: clampCol };
}


